// Code generated by protoc-gen-go. DO NOT EDIT.
// source: kafkapixy.proto

/*
Package pb is a generated protocol buffer package.

It is generated from these files:
	kafkapixy.proto

It has these top-level messages:
	ProdRq
	ProdRs
	ConsNAckRq
	ConsRs
	AckRq
	AckRs
	PartitionOffset
	GetOffsetsRq
	GetOffsetsRs
	PartitionMetadata
	GetTopicMetadataRq
	GetTopicMetadataRs
	ListTopicRs
	ListTopicRq
	ListConsumersRq
	ConsumerPartitions
	ConsumerGroups
	ListConsumersRs
	SetOffsetsRq
	SetOffsetsRs
*/
package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ProdRq struct {
	// Name of a Kafka cluster to operate on.
	Cluster string `protobuf:"bytes,1,opt,name=cluster" json:"cluster,omitempty"`
	// Name of a topic to produce to.
	Topic string `protobuf:"bytes,2,opt,name=topic" json:"topic,omitempty"`
	// Hash of the key is used to determine the partition to produce to. By
	// default it is an empty array which is a valid key, unless key_undefined
	// is set to true and then a random partition is selected.
	KeyValue []byte `protobuf:"bytes,3,opt,name=key_value,json=keyValue,proto3" json:"key_value,omitempty"`
	// If true then the message is written to a random partition, otherwise
	// hash of key_value is used to determine the partition.
	KeyUndefined bool `protobuf:"varint,4,opt,name=key_undefined,json=keyUndefined" json:"key_undefined,omitempty"`
	// Message body.
	Message []byte `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
	// If true then the method returns immediately after Kafka-Pixy gets the
	// produce request, and the message is written to Kafka asynchronously.
	// In that case partition and offset returned in response should be ignored.
	// If false, then a response is returned in accordance with the
	// producer.required_acks parameter, that can be one of:
	//  * no_response:    the response is returned as soon as a produce request
	//                    is delivered to a partition leader Kafka broker.
	//  * wait_for_local: the response is returned as soon as data is written
	//                    to the disk by a partition leader Kafka broker.
	//  * wait_for_all:   the response is returned after all in-sync replicas
	//                    have data committed to disk.
	AsyncMode bool `protobuf:"varint,6,opt,name=async_mode,json=asyncMode" json:"async_mode,omitempty"`
}

func (m *ProdRq) Reset()                    { *m = ProdRq{} }
func (m *ProdRq) String() string            { return proto.CompactTextString(m) }
func (*ProdRq) ProtoMessage()               {}
func (*ProdRq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ProdRq) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *ProdRq) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *ProdRq) GetKeyValue() []byte {
	if m != nil {
		return m.KeyValue
	}
	return nil
}

func (m *ProdRq) GetKeyUndefined() bool {
	if m != nil {
		return m.KeyUndefined
	}
	return false
}

func (m *ProdRq) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *ProdRq) GetAsyncMode() bool {
	if m != nil {
		return m.AsyncMode
	}
	return false
}

type ProdRs struct {
	// Partition the message was written to. The value only makes sense if
	// ProdReq.async_mode was false.
	Partition int32 `protobuf:"varint,1,opt,name=partition" json:"partition,omitempty"`
	// Offset the message was written to. The value only makes sense if
	// ProdReq.async_mode was false.
	Offset int64 `protobuf:"varint,2,opt,name=offset" json:"offset,omitempty"`
}

func (m *ProdRs) Reset()                    { *m = ProdRs{} }
func (m *ProdRs) String() string            { return proto.CompactTextString(m) }
func (*ProdRs) ProtoMessage()               {}
func (*ProdRs) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ProdRs) GetPartition() int32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *ProdRs) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

type ConsNAckRq struct {
	// Name of a Kafka cluster to operate on.
	Cluster string `protobuf:"bytes,1,opt,name=cluster" json:"cluster,omitempty"`
	// Name of a topic to produce to.
	Topic string `protobuf:"bytes,2,opt,name=topic" json:"topic,omitempty"`
	// Name of a consumer group.
	Group string `protobuf:"bytes,3,opt,name=group" json:"group,omitempty"`
	// If true then no message is acknowledged by the request.
	NoAck bool `protobuf:"varint,4,opt,name=no_ack,json=noAck" json:"no_ack,omitempty"`
	// If true and no_ack is false then the message returned by the requests is
	// automatically acknowledged by Kafka-Pixy before the request completes.
	AutoAck bool `protobuf:"varint,5,opt,name=auto_ack,json=autoAck" json:"auto_ack,omitempty"`
	// If both no_ack and auto_ack are false (by default), then ack_partition
	// and ack_offset along with cluster-group-topic determine the message that
	// should be acknowledged by the request.
	AckPartition int32 `protobuf:"varint,6,opt,name=ack_partition,json=ackPartition" json:"ack_partition,omitempty"`
	AckOffset    int64 `protobuf:"varint,7,opt,name=ack_offset,json=ackOffset" json:"ack_offset,omitempty"`
}

func (m *ConsNAckRq) Reset()                    { *m = ConsNAckRq{} }
func (m *ConsNAckRq) String() string            { return proto.CompactTextString(m) }
func (*ConsNAckRq) ProtoMessage()               {}
func (*ConsNAckRq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ConsNAckRq) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *ConsNAckRq) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *ConsNAckRq) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *ConsNAckRq) GetNoAck() bool {
	if m != nil {
		return m.NoAck
	}
	return false
}

func (m *ConsNAckRq) GetAutoAck() bool {
	if m != nil {
		return m.AutoAck
	}
	return false
}

func (m *ConsNAckRq) GetAckPartition() int32 {
	if m != nil {
		return m.AckPartition
	}
	return 0
}

func (m *ConsNAckRq) GetAckOffset() int64 {
	if m != nil {
		return m.AckOffset
	}
	return 0
}

type ConsRs struct {
	// Partition the message was read from.
	Partition int32 `protobuf:"varint,1,opt,name=partition" json:"partition,omitempty"`
	// Offset of the read message in the partition.
	Offset int64 `protobuf:"varint,2,opt,name=offset" json:"offset,omitempty"`
	// Key that was used to produce the message, unless key_undefined is true,
	// then it is undefined.
	KeyValue []byte `protobuf:"bytes,3,opt,name=key_value,json=keyValue,proto3" json:"key_value,omitempty"`
	// If true then the message was produced to a random partition.
	KeyUndefined bool `protobuf:"varint,4,opt,name=key_undefined,json=keyUndefined" json:"key_undefined,omitempty"`
	// Message body
	Message []byte `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *ConsRs) Reset()                    { *m = ConsRs{} }
func (m *ConsRs) String() string            { return proto.CompactTextString(m) }
func (*ConsRs) ProtoMessage()               {}
func (*ConsRs) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ConsRs) GetPartition() int32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *ConsRs) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *ConsRs) GetKeyValue() []byte {
	if m != nil {
		return m.KeyValue
	}
	return nil
}

func (m *ConsRs) GetKeyUndefined() bool {
	if m != nil {
		return m.KeyUndefined
	}
	return false
}

func (m *ConsRs) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

type AckRq struct {
	// Name of a Kafka cluster to operate on.
	Cluster string `protobuf:"bytes,1,opt,name=cluster" json:"cluster,omitempty"`
	// Name of a topic to produce to.
	Topic string `protobuf:"bytes,2,opt,name=topic" json:"topic,omitempty"`
	// Name of a consumer group.
	Group string `protobuf:"bytes,3,opt,name=group" json:"group,omitempty"`
	// Partition that the acknowledged message was consumed from.
	Partition int32 `protobuf:"varint,4,opt,name=partition" json:"partition,omitempty"`
	// Offset in the partition that the acknowledged message was consumed from.
	Offset int64 `protobuf:"varint,5,opt,name=offset" json:"offset,omitempty"`
}

func (m *AckRq) Reset()                    { *m = AckRq{} }
func (m *AckRq) String() string            { return proto.CompactTextString(m) }
func (*AckRq) ProtoMessage()               {}
func (*AckRq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *AckRq) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *AckRq) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *AckRq) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *AckRq) GetPartition() int32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *AckRq) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

type AckRs struct {
}

func (m *AckRs) Reset()                    { *m = AckRs{} }
func (m *AckRs) String() string            { return proto.CompactTextString(m) }
func (*AckRs) ProtoMessage()               {}
func (*AckRs) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type PartitionOffset struct {
	// The Partition this structure describes
	Partition int32 `protobuf:"varint,1,opt,name=partition" json:"partition,omitempty"`
	// The beginning offset
	Begin int64 `protobuf:"varint,2,opt,name=begin" json:"begin,omitempty"`
	// The ending offset
	End int64 `protobuf:"varint,3,opt,name=end" json:"end,omitempty"`
	// The number of messages in the partition
	Count int64 `protobuf:"varint,4,opt,name=count" json:"count,omitempty"`
	// Offset in the partition
	Offset int64 `protobuf:"varint,5,opt,name=offset" json:"offset,omitempty"`
	// The number of un-consumed messages in the partition
	Lag int64 `protobuf:"varint,6,opt,name=lag" json:"lag,omitempty"`
	// Metatdata associated with the partition
	Metadata string `protobuf:"bytes,7,opt,name=metadata" json:"metadata,omitempty"`
	// human readable representation of sparsely committed ranges
	SparseAcks string `protobuf:"bytes,8,opt,name=sparse_acks,json=sparseAcks" json:"sparse_acks,omitempty"`
}

func (m *PartitionOffset) Reset()                    { *m = PartitionOffset{} }
func (m *PartitionOffset) String() string            { return proto.CompactTextString(m) }
func (*PartitionOffset) ProtoMessage()               {}
func (*PartitionOffset) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *PartitionOffset) GetPartition() int32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *PartitionOffset) GetBegin() int64 {
	if m != nil {
		return m.Begin
	}
	return 0
}

func (m *PartitionOffset) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *PartitionOffset) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *PartitionOffset) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *PartitionOffset) GetLag() int64 {
	if m != nil {
		return m.Lag
	}
	return 0
}

func (m *PartitionOffset) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *PartitionOffset) GetSparseAcks() string {
	if m != nil {
		return m.SparseAcks
	}
	return ""
}

type GetOffsetsRq struct {
	// Name of a Kafka cluster
	Cluster string `protobuf:"bytes,1,opt,name=cluster" json:"cluster,omitempty"`
	// Name of a topic
	Topic string `protobuf:"bytes,2,opt,name=topic" json:"topic,omitempty"`
	// Name of a consumer group.
	Group string `protobuf:"bytes,3,opt,name=group" json:"group,omitempty"`
}

func (m *GetOffsetsRq) Reset()                    { *m = GetOffsetsRq{} }
func (m *GetOffsetsRq) String() string            { return proto.CompactTextString(m) }
func (*GetOffsetsRq) ProtoMessage()               {}
func (*GetOffsetsRq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *GetOffsetsRq) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *GetOffsetsRq) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *GetOffsetsRq) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

type GetOffsetsRs struct {
	Offsets []*PartitionOffset `protobuf:"bytes,1,rep,name=offsets" json:"offsets,omitempty"`
}

func (m *GetOffsetsRs) Reset()                    { *m = GetOffsetsRs{} }
func (m *GetOffsetsRs) String() string            { return proto.CompactTextString(m) }
func (*GetOffsetsRs) ProtoMessage()               {}
func (*GetOffsetsRs) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *GetOffsetsRs) GetOffsets() []*PartitionOffset {
	if m != nil {
		return m.Offsets
	}
	return nil
}

// Partition metadata as retrieved from kafka
type PartitionMetadata struct {
	// The Partition this structure describes
	Partition int32 `protobuf:"varint,1,opt,name=partition" json:"partition,omitempty"`
	// The node id for the kafka broker currently acting as leader for this partition.
	// If no leader exists because we are in the middle of a leader election this id will be -1.
	Leader int32 `protobuf:"varint,2,opt,name=leader" json:"leader,omitempty"`
	// The set of alive nodes that currently acts as slaves for the leader for this partition.
	Replicas []int32 `protobuf:"varint,3,rep,packed,name=replicas" json:"replicas,omitempty"`
	// The set subset of the replicas that are "caught up" to the leader
	Isr []int32 `protobuf:"varint,4,rep,packed,name=isr" json:"isr,omitempty"`
}

func (m *PartitionMetadata) Reset()                    { *m = PartitionMetadata{} }
func (m *PartitionMetadata) String() string            { return proto.CompactTextString(m) }
func (*PartitionMetadata) ProtoMessage()               {}
func (*PartitionMetadata) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *PartitionMetadata) GetPartition() int32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *PartitionMetadata) GetLeader() int32 {
	if m != nil {
		return m.Leader
	}
	return 0
}

func (m *PartitionMetadata) GetReplicas() []int32 {
	if m != nil {
		return m.Replicas
	}
	return nil
}

func (m *PartitionMetadata) GetIsr() []int32 {
	if m != nil {
		return m.Isr
	}
	return nil
}

type GetTopicMetadataRq struct {
	// Name of a Kafka cluster
	Cluster string `protobuf:"bytes,1,opt,name=cluster" json:"cluster,omitempty"`
	// Name of a topic
	Topic string `protobuf:"bytes,2,opt,name=topic" json:"topic,omitempty"`
	// Should include partition metadata
	WithPartitions bool `protobuf:"varint,3,opt,name=with_partitions,json=withPartitions" json:"with_partitions,omitempty"`
}

func (m *GetTopicMetadataRq) Reset()                    { *m = GetTopicMetadataRq{} }
func (m *GetTopicMetadataRq) String() string            { return proto.CompactTextString(m) }
func (*GetTopicMetadataRq) ProtoMessage()               {}
func (*GetTopicMetadataRq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *GetTopicMetadataRq) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *GetTopicMetadataRq) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *GetTopicMetadataRq) GetWithPartitions() bool {
	if m != nil {
		return m.WithPartitions
	}
	return false
}

type GetTopicMetadataRs struct {
	// Version of this metadata
	Version int32 `protobuf:"varint,1,opt,name=version" json:"version,omitempty"`
	// Config values
	Config map[string]string `protobuf:"bytes,2,rep,name=config" json:"config,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Optional list of metadata for the partitions of this topic
	Partitions []*PartitionMetadata `protobuf:"bytes,3,rep,name=partitions" json:"partitions,omitempty"`
}

func (m *GetTopicMetadataRs) Reset()                    { *m = GetTopicMetadataRs{} }
func (m *GetTopicMetadataRs) String() string            { return proto.CompactTextString(m) }
func (*GetTopicMetadataRs) ProtoMessage()               {}
func (*GetTopicMetadataRs) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *GetTopicMetadataRs) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *GetTopicMetadataRs) GetConfig() map[string]string {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *GetTopicMetadataRs) GetPartitions() []*PartitionMetadata {
	if m != nil {
		return m.Partitions
	}
	return nil
}

type ListTopicRs struct {
	Topics map[string]*GetTopicMetadataRs `protobuf:"bytes,1,rep,name=topics" json:"topics,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ListTopicRs) Reset()                    { *m = ListTopicRs{} }
func (m *ListTopicRs) String() string            { return proto.CompactTextString(m) }
func (*ListTopicRs) ProtoMessage()               {}
func (*ListTopicRs) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *ListTopicRs) GetTopics() map[string]*GetTopicMetadataRs {
	if m != nil {
		return m.Topics
	}
	return nil
}

type ListTopicRq struct {
	// Name of a Kafka cluster
	Cluster string `protobuf:"bytes,1,opt,name=cluster" json:"cluster,omitempty"`
	// Should include partition metadata
	WithPartitions bool `protobuf:"varint,2,opt,name=with_partitions,json=withPartitions" json:"with_partitions,omitempty"`
}

func (m *ListTopicRq) Reset()                    { *m = ListTopicRq{} }
func (m *ListTopicRq) String() string            { return proto.CompactTextString(m) }
func (*ListTopicRq) ProtoMessage()               {}
func (*ListTopicRq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *ListTopicRq) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *ListTopicRq) GetWithPartitions() bool {
	if m != nil {
		return m.WithPartitions
	}
	return false
}

type ListConsumersRq struct {
	// Name of a Kafka cluster
	Cluster string `protobuf:"bytes,1,opt,name=cluster" json:"cluster,omitempty"`
	// Name of a topic
	Topic string `protobuf:"bytes,2,opt,name=topic" json:"topic,omitempty"`
	// If non empty, return only the specified group in the result
	Group string `protobuf:"bytes,3,opt,name=group" json:"group,omitempty"`
}

func (m *ListConsumersRq) Reset()                    { *m = ListConsumersRq{} }
func (m *ListConsumersRq) String() string            { return proto.CompactTextString(m) }
func (*ListConsumersRq) ProtoMessage()               {}
func (*ListConsumersRq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *ListConsumersRq) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *ListConsumersRq) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *ListConsumersRq) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

type ConsumerPartitions struct {
	Partitions []int32 `protobuf:"varint,1,rep,packed,name=partitions" json:"partitions,omitempty"`
}

func (m *ConsumerPartitions) Reset()                    { *m = ConsumerPartitions{} }
func (m *ConsumerPartitions) String() string            { return proto.CompactTextString(m) }
func (*ConsumerPartitions) ProtoMessage()               {}
func (*ConsumerPartitions) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *ConsumerPartitions) GetPartitions() []int32 {
	if m != nil {
		return m.Partitions
	}
	return nil
}

type ConsumerGroups struct {
	Consumers map[string]*ConsumerPartitions `protobuf:"bytes,1,rep,name=consumers" json:"consumers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ConsumerGroups) Reset()                    { *m = ConsumerGroups{} }
func (m *ConsumerGroups) String() string            { return proto.CompactTextString(m) }
func (*ConsumerGroups) ProtoMessage()               {}
func (*ConsumerGroups) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *ConsumerGroups) GetConsumers() map[string]*ConsumerPartitions {
	if m != nil {
		return m.Consumers
	}
	return nil
}

type ListConsumersRs struct {
	Groups map[string]*ConsumerGroups `protobuf:"bytes,1,rep,name=groups" json:"groups,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ListConsumersRs) Reset()                    { *m = ListConsumersRs{} }
func (m *ListConsumersRs) String() string            { return proto.CompactTextString(m) }
func (*ListConsumersRs) ProtoMessage()               {}
func (*ListConsumersRs) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *ListConsumersRs) GetGroups() map[string]*ConsumerGroups {
	if m != nil {
		return m.Groups
	}
	return nil
}

type SetOffsetsRq struct {
	// Name of a Kafka cluster
	Cluster string `protobuf:"bytes,1,opt,name=cluster" json:"cluster,omitempty"`
	// Name of a topic
	Topic string `protobuf:"bytes,2,opt,name=topic" json:"topic,omitempty"`
	// Name of a consumer group.
	Group   string             `protobuf:"bytes,3,opt,name=group" json:"group,omitempty"`
	Offsets []*PartitionOffset `protobuf:"bytes,4,rep,name=offsets" json:"offsets,omitempty"`
}

func (m *SetOffsetsRq) Reset()                    { *m = SetOffsetsRq{} }
func (m *SetOffsetsRq) String() string            { return proto.CompactTextString(m) }
func (*SetOffsetsRq) ProtoMessage()               {}
func (*SetOffsetsRq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *SetOffsetsRq) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *SetOffsetsRq) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *SetOffsetsRq) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *SetOffsetsRq) GetOffsets() []*PartitionOffset {
	if m != nil {
		return m.Offsets
	}
	return nil
}

type SetOffsetsRs struct {
}

func (m *SetOffsetsRs) Reset()                    { *m = SetOffsetsRs{} }
func (m *SetOffsetsRs) String() string            { return proto.CompactTextString(m) }
func (*SetOffsetsRs) ProtoMessage()               {}
func (*SetOffsetsRs) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func init() {
	proto.RegisterType((*ProdRq)(nil), "ProdRq")
	proto.RegisterType((*ProdRs)(nil), "ProdRs")
	proto.RegisterType((*ConsNAckRq)(nil), "ConsNAckRq")
	proto.RegisterType((*ConsRs)(nil), "ConsRs")
	proto.RegisterType((*AckRq)(nil), "AckRq")
	proto.RegisterType((*AckRs)(nil), "AckRs")
	proto.RegisterType((*PartitionOffset)(nil), "PartitionOffset")
	proto.RegisterType((*GetOffsetsRq)(nil), "GetOffsetsRq")
	proto.RegisterType((*GetOffsetsRs)(nil), "GetOffsetsRs")
	proto.RegisterType((*PartitionMetadata)(nil), "PartitionMetadata")
	proto.RegisterType((*GetTopicMetadataRq)(nil), "GetTopicMetadataRq")
	proto.RegisterType((*GetTopicMetadataRs)(nil), "GetTopicMetadataRs")
	proto.RegisterType((*ListTopicRs)(nil), "ListTopicRs")
	proto.RegisterType((*ListTopicRq)(nil), "ListTopicRq")
	proto.RegisterType((*ListConsumersRq)(nil), "ListConsumersRq")
	proto.RegisterType((*ConsumerPartitions)(nil), "ConsumerPartitions")
	proto.RegisterType((*ConsumerGroups)(nil), "ConsumerGroups")
	proto.RegisterType((*ListConsumersRs)(nil), "ListConsumersRs")
	proto.RegisterType((*SetOffsetsRq)(nil), "SetOffsetsRq")
	proto.RegisterType((*SetOffsetsRs)(nil), "SetOffsetsRs")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for KafkaPixy service

type KafkaPixyClient interface {
	// Produce writes a message to a Kafka topic.
	//
	// If ProdReq.async_mode is false (default value) then the request will
	// block until the message is written to all ISR. In this case the respose
	// will contain the partition and offset of the message. This has to be
	// used to achive at-least-once deliverability guarantee.
	// If ProdReq.async_mode is true, then Kafka-Pixy returns immediately after
	// it gets the request and performs write on the backgroud. This mode
	// ensures highest throughput but messages can be lost, e.g. if the host
	// crashes before Kafka-Pixy has a chance to complete write.
	//
	// Hash of ProdReq.key_value is used to determine a partition that the
	// message should be written to. If you want a message to go to an random
	// partition then set ProdReq.key_undefined to true. Note that if both
	// ProdReq.key_undefined and ProdReq.key_value are left default, which is
	// empty string and false respectively, then messages will be consitently
	// written to a partiticular partition selected by the hash of an empty
	// string.
	//
	// gRPC error codes:
	//  * Invalid Argument (3): see the status description for details;
	//  * Internal (13): see the status description and logs for details;
	//  * Unavailable (14): the service is shutting down.
	Produce(ctx context.Context, in *ProdRq, opts ...grpc.CallOption) (*ProdRs, error)
	// Consume reads a message from a topic and optionally acknowledges a
	// message previously consumed from the same topic.
	//
	// Requests are performed in long polling fation, that is if all available
	// messages have been consumed then the request will block for
	// config.yaml:proxies.<cluster>.consumer.long_polling_timeout waiting for
	// new messages. If no new messages is produced while waiting the request
	// will return gRPC error with 408 status code.
	//
	// To consume the first message set ConsNAckReq.no_ack to true, since there
	// is no message to acknowledge at this point. In the second and all
	// subsequent calls of the method set ConsNAckReq.ack_partition and
	// ConsNAckReq.ack_offset to the respective values of ConsRes returned by
	// the previous method call. To acknowledge the last consumed message before
	// teminating the application call Ack method.
	//
	// If a message is not acknowledged within
	// config.yaml:proxies.<cluster>.consumer.ack_timeout the it will be returned
	// by Kafka-Pixy in ConsRes again possibly to another application.
	//
	// If at-least-once delivery guarantee and retries are not desirable, then
	// you can set ConsNAckReq.auto_ack to true and Kafka-Pixy will acknowledge
	// messages automatically before returning them in ConsRes.
	//
	// gRPC error codes:
	//  * Not Found (5): It just means that all message has been consumed and
	//    the long polling timeout has elaspsed. Just keep calling this method
	//    in a loop;
	//  * Resource Exhausted (8): too many consume requests. Either reduce the
	//    number of consuming threads or increase
	//    config.yaml:proxies.<cluster>.consumer.channel_buffer_size;
	//  * Invalid Argument (3): see the status description for details;
	//  * Internal (13): see the status description and logs for details;
	//  * Unavailable (14): the service is shutting down.
	ConsumeNAck(ctx context.Context, in *ConsNAckRq, opts ...grpc.CallOption) (*ConsRs, error)
	// Ack acknowledges a message earlier consumed from a topic.
	//
	// This method is provided solely to acknowledge the last consumed message
	// before the application terminates. In all other cases ConsumeNAck should
	// be used.
	//
	// gRPC error codes:
	//  * Invalid Argument (3): see the status description for details;
	//  * Internal (13): see the status description and logs for details;
	Ack(ctx context.Context, in *AckRq, opts ...grpc.CallOption) (*AckRs, error)
	// Fetches partition offsets for the specified topic and group
	//
	// gRPC error codes:
	//  * Invalid Argument (3): If unable to find the cluster named in the request
	//  * Internal (13): If Kafka returns an error on offset request
	//  * NotFound (5): If the group and or topic does not exist
	GetOffsets(ctx context.Context, in *GetOffsetsRq, opts ...grpc.CallOption) (*GetOffsetsRs, error)
	// Sets partition offsets for the specified topic and group.
	// NOTE: Although the request accepts the PartitionOffset object i
	// only 'Partition', 'Offset' and 'Metadata' are set by this method
	//
	// gRPC error codes:
	//  * Invalid Argument (3): If unable to find the cluster named in the request
	//  * Internal (13): If Kafka returns an error on offset request
	//  * NotFound (5): If the group and or topic does not exist
	SetOffsets(ctx context.Context, in *SetOffsetsRq, opts ...grpc.CallOption) (*SetOffsetsRs, error)
	// Lists all topics and metadata with optional metadata for the partitions of the topic
	//
	// gRPC error codes:
	//  * Invalid Argument (3): If unable to find the cluster named in the request
	//  * Internal (13): If Kafka returns an error on request
	ListTopics(ctx context.Context, in *ListTopicRq, opts ...grpc.CallOption) (*ListTopicRs, error)
	// Lists all consumers of a topic
	//
	// gRPC error codes:
	//  * Invalid Argument (3): If unable to find the cluster named in the request
	//  * Internal (13): If Kafka returns an error on request
	ListConsumers(ctx context.Context, in *ListConsumersRq, opts ...grpc.CallOption) (*ListConsumersRs, error)
	// Fetches topic metadata and optional metadata for the partitions of the topic
	//
	// gRPC error codes:
	//  * Invalid Argument (3): If unable to find the cluster named in the request
	//  * Internal (13): If Kafka returns an error on request
	//  * NotFound (5): If the topic does not exist
	GetTopicMetadata(ctx context.Context, in *GetTopicMetadataRq, opts ...grpc.CallOption) (*GetTopicMetadataRs, error)
}

type kafkaPixyClient struct {
	cc *grpc.ClientConn
}

func NewKafkaPixyClient(cc *grpc.ClientConn) KafkaPixyClient {
	return &kafkaPixyClient{cc}
}

func (c *kafkaPixyClient) Produce(ctx context.Context, in *ProdRq, opts ...grpc.CallOption) (*ProdRs, error) {
	out := new(ProdRs)
	err := grpc.Invoke(ctx, "/KafkaPixy/Produce", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaPixyClient) ConsumeNAck(ctx context.Context, in *ConsNAckRq, opts ...grpc.CallOption) (*ConsRs, error) {
	out := new(ConsRs)
	err := grpc.Invoke(ctx, "/KafkaPixy/ConsumeNAck", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaPixyClient) Ack(ctx context.Context, in *AckRq, opts ...grpc.CallOption) (*AckRs, error) {
	out := new(AckRs)
	err := grpc.Invoke(ctx, "/KafkaPixy/Ack", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaPixyClient) GetOffsets(ctx context.Context, in *GetOffsetsRq, opts ...grpc.CallOption) (*GetOffsetsRs, error) {
	out := new(GetOffsetsRs)
	err := grpc.Invoke(ctx, "/KafkaPixy/GetOffsets", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaPixyClient) SetOffsets(ctx context.Context, in *SetOffsetsRq, opts ...grpc.CallOption) (*SetOffsetsRs, error) {
	out := new(SetOffsetsRs)
	err := grpc.Invoke(ctx, "/KafkaPixy/SetOffsets", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaPixyClient) ListTopics(ctx context.Context, in *ListTopicRq, opts ...grpc.CallOption) (*ListTopicRs, error) {
	out := new(ListTopicRs)
	err := grpc.Invoke(ctx, "/KafkaPixy/ListTopics", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaPixyClient) ListConsumers(ctx context.Context, in *ListConsumersRq, opts ...grpc.CallOption) (*ListConsumersRs, error) {
	out := new(ListConsumersRs)
	err := grpc.Invoke(ctx, "/KafkaPixy/ListConsumers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaPixyClient) GetTopicMetadata(ctx context.Context, in *GetTopicMetadataRq, opts ...grpc.CallOption) (*GetTopicMetadataRs, error) {
	out := new(GetTopicMetadataRs)
	err := grpc.Invoke(ctx, "/KafkaPixy/GetTopicMetadata", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for KafkaPixy service

type KafkaPixyServer interface {
	// Produce writes a message to a Kafka topic.
	//
	// If ProdReq.async_mode is false (default value) then the request will
	// block until the message is written to all ISR. In this case the respose
	// will contain the partition and offset of the message. This has to be
	// used to achive at-least-once deliverability guarantee.
	// If ProdReq.async_mode is true, then Kafka-Pixy returns immediately after
	// it gets the request and performs write on the backgroud. This mode
	// ensures highest throughput but messages can be lost, e.g. if the host
	// crashes before Kafka-Pixy has a chance to complete write.
	//
	// Hash of ProdReq.key_value is used to determine a partition that the
	// message should be written to. If you want a message to go to an random
	// partition then set ProdReq.key_undefined to true. Note that if both
	// ProdReq.key_undefined and ProdReq.key_value are left default, which is
	// empty string and false respectively, then messages will be consitently
	// written to a partiticular partition selected by the hash of an empty
	// string.
	//
	// gRPC error codes:
	//  * Invalid Argument (3): see the status description for details;
	//  * Internal (13): see the status description and logs for details;
	//  * Unavailable (14): the service is shutting down.
	Produce(context.Context, *ProdRq) (*ProdRs, error)
	// Consume reads a message from a topic and optionally acknowledges a
	// message previously consumed from the same topic.
	//
	// Requests are performed in long polling fation, that is if all available
	// messages have been consumed then the request will block for
	// config.yaml:proxies.<cluster>.consumer.long_polling_timeout waiting for
	// new messages. If no new messages is produced while waiting the request
	// will return gRPC error with 408 status code.
	//
	// To consume the first message set ConsNAckReq.no_ack to true, since there
	// is no message to acknowledge at this point. In the second and all
	// subsequent calls of the method set ConsNAckReq.ack_partition and
	// ConsNAckReq.ack_offset to the respective values of ConsRes returned by
	// the previous method call. To acknowledge the last consumed message before
	// teminating the application call Ack method.
	//
	// If a message is not acknowledged within
	// config.yaml:proxies.<cluster>.consumer.ack_timeout the it will be returned
	// by Kafka-Pixy in ConsRes again possibly to another application.
	//
	// If at-least-once delivery guarantee and retries are not desirable, then
	// you can set ConsNAckReq.auto_ack to true and Kafka-Pixy will acknowledge
	// messages automatically before returning them in ConsRes.
	//
	// gRPC error codes:
	//  * Not Found (5): It just means that all message has been consumed and
	//    the long polling timeout has elaspsed. Just keep calling this method
	//    in a loop;
	//  * Resource Exhausted (8): too many consume requests. Either reduce the
	//    number of consuming threads or increase
	//    config.yaml:proxies.<cluster>.consumer.channel_buffer_size;
	//  * Invalid Argument (3): see the status description for details;
	//  * Internal (13): see the status description and logs for details;
	//  * Unavailable (14): the service is shutting down.
	ConsumeNAck(context.Context, *ConsNAckRq) (*ConsRs, error)
	// Ack acknowledges a message earlier consumed from a topic.
	//
	// This method is provided solely to acknowledge the last consumed message
	// before the application terminates. In all other cases ConsumeNAck should
	// be used.
	//
	// gRPC error codes:
	//  * Invalid Argument (3): see the status description for details;
	//  * Internal (13): see the status description and logs for details;
	Ack(context.Context, *AckRq) (*AckRs, error)
	// Fetches partition offsets for the specified topic and group
	//
	// gRPC error codes:
	//  * Invalid Argument (3): If unable to find the cluster named in the request
	//  * Internal (13): If Kafka returns an error on offset request
	//  * NotFound (5): If the group and or topic does not exist
	GetOffsets(context.Context, *GetOffsetsRq) (*GetOffsetsRs, error)
	// Sets partition offsets for the specified topic and group.
	// NOTE: Although the request accepts the PartitionOffset object i
	// only 'Partition', 'Offset' and 'Metadata' are set by this method
	//
	// gRPC error codes:
	//  * Invalid Argument (3): If unable to find the cluster named in the request
	//  * Internal (13): If Kafka returns an error on offset request
	//  * NotFound (5): If the group and or topic does not exist
	SetOffsets(context.Context, *SetOffsetsRq) (*SetOffsetsRs, error)
	// Lists all topics and metadata with optional metadata for the partitions of the topic
	//
	// gRPC error codes:
	//  * Invalid Argument (3): If unable to find the cluster named in the request
	//  * Internal (13): If Kafka returns an error on request
	ListTopics(context.Context, *ListTopicRq) (*ListTopicRs, error)
	// Lists all consumers of a topic
	//
	// gRPC error codes:
	//  * Invalid Argument (3): If unable to find the cluster named in the request
	//  * Internal (13): If Kafka returns an error on request
	ListConsumers(context.Context, *ListConsumersRq) (*ListConsumersRs, error)
	// Fetches topic metadata and optional metadata for the partitions of the topic
	//
	// gRPC error codes:
	//  * Invalid Argument (3): If unable to find the cluster named in the request
	//  * Internal (13): If Kafka returns an error on request
	//  * NotFound (5): If the topic does not exist
	GetTopicMetadata(context.Context, *GetTopicMetadataRq) (*GetTopicMetadataRs, error)
}

func RegisterKafkaPixyServer(s *grpc.Server, srv KafkaPixyServer) {
	s.RegisterService(&_KafkaPixy_serviceDesc, srv)
}

func _KafkaPixy_Produce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProdRq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaPixyServer).Produce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/KafkaPixy/Produce",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaPixyServer).Produce(ctx, req.(*ProdRq))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaPixy_ConsumeNAck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConsNAckRq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaPixyServer).ConsumeNAck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/KafkaPixy/ConsumeNAck",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaPixyServer).ConsumeNAck(ctx, req.(*ConsNAckRq))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaPixy_Ack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AckRq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaPixyServer).Ack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/KafkaPixy/Ack",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaPixyServer).Ack(ctx, req.(*AckRq))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaPixy_GetOffsets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOffsetsRq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaPixyServer).GetOffsets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/KafkaPixy/GetOffsets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaPixyServer).GetOffsets(ctx, req.(*GetOffsetsRq))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaPixy_SetOffsets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetOffsetsRq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaPixyServer).SetOffsets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/KafkaPixy/SetOffsets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaPixyServer).SetOffsets(ctx, req.(*SetOffsetsRq))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaPixy_ListTopics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTopicRq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaPixyServer).ListTopics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/KafkaPixy/ListTopics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaPixyServer).ListTopics(ctx, req.(*ListTopicRq))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaPixy_ListConsumers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListConsumersRq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaPixyServer).ListConsumers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/KafkaPixy/ListConsumers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaPixyServer).ListConsumers(ctx, req.(*ListConsumersRq))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaPixy_GetTopicMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTopicMetadataRq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaPixyServer).GetTopicMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/KafkaPixy/GetTopicMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaPixyServer).GetTopicMetadata(ctx, req.(*GetTopicMetadataRq))
	}
	return interceptor(ctx, in, info, handler)
}

var _KafkaPixy_serviceDesc = grpc.ServiceDesc{
	ServiceName: "KafkaPixy",
	HandlerType: (*KafkaPixyServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Produce",
			Handler:    _KafkaPixy_Produce_Handler,
		},
		{
			MethodName: "ConsumeNAck",
			Handler:    _KafkaPixy_ConsumeNAck_Handler,
		},
		{
			MethodName: "Ack",
			Handler:    _KafkaPixy_Ack_Handler,
		},
		{
			MethodName: "GetOffsets",
			Handler:    _KafkaPixy_GetOffsets_Handler,
		},
		{
			MethodName: "SetOffsets",
			Handler:    _KafkaPixy_SetOffsets_Handler,
		},
		{
			MethodName: "ListTopics",
			Handler:    _KafkaPixy_ListTopics_Handler,
		},
		{
			MethodName: "ListConsumers",
			Handler:    _KafkaPixy_ListConsumers_Handler,
		},
		{
			MethodName: "GetTopicMetadata",
			Handler:    _KafkaPixy_GetTopicMetadata_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "kafkapixy.proto",
}

func init() { proto.RegisterFile("kafkapixy.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 954 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0xdd, 0x6e, 0xe3, 0x44,
	0x14, 0xee, 0xc4, 0xb1, 0x13, 0x9f, 0xa4, 0x4d, 0x19, 0x0a, 0x18, 0xb3, 0x3f, 0x91, 0x57, 0x2b,
	0xc2, 0x0a, 0x59, 0xa8, 0x2c, 0x02, 0x56, 0x68, 0xa5, 0xb2, 0x42, 0x95, 0x80, 0x5d, 0xca, 0x74,
	0x01, 0x89, 0x9b, 0x68, 0xea, 0x4c, 0x82, 0xe5, 0xc4, 0x4e, 0x3d, 0xce, 0xee, 0xe6, 0x0e, 0x89,
	0x07, 0xe0, 0x82, 0x3b, 0xee, 0x78, 0x06, 0x5e, 0x82, 0x07, 0x40, 0xbc, 0x03, 0x6f, 0x81, 0xce,
	0x8c, 0x1d, 0xdb, 0xa9, 0x97, 0xa2, 0xaa, 0x5c, 0xc5, 0xdf, 0x39, 0x67, 0x66, 0xbe, 0xef, 0x3b,
	0x33, 0x93, 0x81, 0x41, 0xc4, 0xa7, 0x11, 0x5f, 0x86, 0x2f, 0xd6, 0xfe, 0x32, 0x4d, 0xb2, 0xc4,
	0xfb, 0x9d, 0x80, 0x75, 0x92, 0x26, 0x13, 0x76, 0x4e, 0x1d, 0xe8, 0x04, 0xf3, 0x95, 0xcc, 0x44,
	0xea, 0x90, 0x21, 0x19, 0xd9, 0xac, 0x80, 0xf4, 0x00, 0xcc, 0x2c, 0x59, 0x86, 0x81, 0xd3, 0x52,
	0x71, 0x0d, 0xe8, 0x5b, 0x60, 0x47, 0x62, 0x3d, 0x7e, 0xc6, 0xe7, 0x2b, 0xe1, 0x18, 0x43, 0x32,
	0xea, 0xb3, 0x6e, 0x24, 0xd6, 0xdf, 0x22, 0xa6, 0x77, 0x60, 0x17, 0x93, 0xab, 0x78, 0x22, 0xa6,
	0x61, 0x2c, 0x26, 0x4e, 0x7b, 0x48, 0x46, 0x5d, 0xd6, 0x8f, 0xc4, 0xfa, 0x9b, 0x22, 0x86, 0x2b,
	0x2e, 0x84, 0x94, 0x7c, 0x26, 0x1c, 0x53, 0x8d, 0x2f, 0x20, 0xbd, 0x09, 0xc0, 0xe5, 0x3a, 0x0e,
	0xc6, 0x8b, 0x64, 0x22, 0x1c, 0x4b, 0x8d, 0xb5, 0x55, 0xe4, 0x71, 0x32, 0x11, 0xde, 0xc3, 0x9c,
	0xb4, 0xa4, 0x37, 0xc0, 0x5e, 0xf2, 0x34, 0x0b, 0xb3, 0x30, 0x89, 0x15, 0x6d, 0x93, 0x95, 0x01,
	0xfa, 0x3a, 0x58, 0xc9, 0x74, 0x2a, 0x45, 0xa6, 0x98, 0x1b, 0x2c, 0x47, 0xde, 0x1f, 0x04, 0xe0,
	0x51, 0x12, 0xcb, 0x27, 0x47, 0x41, 0x74, 0x05, 0xe5, 0x07, 0x60, 0xce, 0xd2, 0x64, 0xb5, 0x54,
	0xaa, 0x6d, 0xa6, 0x01, 0x7d, 0x0d, 0xac, 0x38, 0x19, 0xf3, 0x20, 0xca, 0xb5, 0x9a, 0x71, 0x72,
	0x14, 0x44, 0xf4, 0x4d, 0xe8, 0xf2, 0x55, 0xa6, 0x13, 0xa6, 0x4a, 0x74, 0x10, 0x63, 0xea, 0x0e,
	0xec, 0xf2, 0x20, 0x1a, 0x97, 0x02, 0x2c, 0x25, 0xa0, 0xcf, 0x83, 0xe8, 0x64, 0xa3, 0x01, 0xad,
	0x08, 0xa2, 0x71, 0xae, 0xa3, 0xa3, 0x74, 0xd8, 0x3c, 0x88, 0xbe, 0xd2, 0x52, 0x7e, 0x25, 0x60,
	0xa1, 0x94, 0xab, 0x7a, 0xf1, 0x7f, 0xb6, 0xd1, 0xfb, 0x89, 0x80, 0x79, 0x9d, 0x16, 0xd7, 0x14,
	0xb6, 0x5f, 0xae, 0xd0, 0xac, 0x75, 0xbb, 0xa3, 0x49, 0x48, 0xef, 0x4f, 0x02, 0x83, 0x8d, 0xb1,
	0xda, 0xbf, 0x4b, 0x4c, 0x3b, 0x00, 0xf3, 0x4c, 0xcc, 0xc2, 0x38, 0xf7, 0x4c, 0x03, 0xba, 0x0f,
	0x86, 0x88, 0x27, 0x8a, 0x9a, 0xc1, 0xf0, 0x13, 0xeb, 0x82, 0x64, 0x15, 0x67, 0x8a, 0x94, 0xc1,
	0x34, 0x78, 0x19, 0x21, 0x1c, 0x3f, 0xe7, 0x33, 0xd5, 0x6d, 0x83, 0xe1, 0x27, 0x75, 0xa1, 0xbb,
	0x10, 0x19, 0x9f, 0xf0, 0x8c, 0xab, 0x16, 0xdb, 0x6c, 0x83, 0xe9, 0x6d, 0xe8, 0xc9, 0x25, 0x4f,
	0xa5, 0xc0, 0x2d, 0x24, 0x9d, 0xae, 0x4a, 0x83, 0x0e, 0x1d, 0x05, 0x91, 0xf4, 0x9e, 0x42, 0xff,
	0x58, 0x64, 0x5a, 0x8f, 0xbc, 0x2e, 0xaf, 0xbd, 0x07, 0xb5, 0x59, 0x25, 0xbd, 0x07, 0x1d, 0x4d,
	0x5f, 0x3a, 0x64, 0x68, 0x8c, 0x7a, 0x87, 0xfb, 0xfe, 0x96, 0x97, 0xac, 0x28, 0xf0, 0x9e, 0xc3,
	0x2b, 0x9b, 0xdc, 0xe3, 0x42, 0xc7, 0xa5, 0xdb, 0x73, 0x2e, 0xf8, 0x44, 0xa4, 0x8a, 0x9b, 0xc9,
	0x72, 0x84, 0xce, 0xa4, 0x62, 0x39, 0x0f, 0x03, 0x2e, 0x1d, 0x63, 0x68, 0x8c, 0x4c, 0xb6, 0xc1,
	0xe8, 0x63, 0x28, 0x53, 0xa7, 0xad, 0xc2, 0xf8, 0xe9, 0x2d, 0x80, 0x1e, 0x8b, 0xec, 0x29, 0xca,
	0x2a, 0xd6, 0xbd, 0x82, 0x21, 0x6f, 0xc3, 0xe0, 0x79, 0x98, 0xfd, 0x50, 0x1e, 0x4c, 0xa9, 0xac,
	0xe9, 0xb2, 0x3d, 0x0c, 0x6f, 0x94, 0x49, 0xef, 0x2f, 0xd2, 0xb0, 0x9e, 0xc4, 0xf5, 0x9e, 0x89,
	0x54, 0x96, 0x3a, 0x0b, 0x48, 0x3f, 0x04, 0x2b, 0x48, 0xe2, 0x69, 0x38, 0x73, 0x5a, 0xca, 0xc3,
	0xdb, 0xfe, 0xc5, 0xe1, 0xfe, 0x23, 0x55, 0xf1, 0x59, 0x9c, 0xa5, 0x6b, 0x96, 0x97, 0xd3, 0x43,
	0x80, 0x1a, 0x1b, 0x1c, 0x4c, 0xfd, 0x0b, 0x26, 0xb3, 0x4a, 0x95, 0xfb, 0x31, 0xf4, 0x2a, 0x53,
	0xa1, 0x5b, 0x91, 0x58, 0xe7, 0x0e, 0xe0, 0x27, 0xaa, 0xd7, 0xc7, 0x3e, 0x57, 0xaf, 0xc0, 0x83,
	0xd6, 0x47, 0xc4, 0xfb, 0x99, 0x40, 0xef, 0xcb, 0x50, 0x6a, 0x6a, 0x4c, 0xd2, 0xf7, 0xc0, 0x52,
	0xd6, 0x14, 0xbd, 0x77, 0xfc, 0x4a, 0xd6, 0x57, 0xbf, 0x32, 0x27, 0xac, 0xeb, 0xdc, 0x27, 0xd0,
	0xab, 0x84, 0x1b, 0x16, 0x7f, 0xa7, 0xba, 0x78, 0xef, 0xf0, 0xd5, 0x06, 0x27, 0xaa, 0x8c, 0x4e,
	0xaa, 0x84, 0xfe, 0xad, 0xa5, 0x0d, 0xcd, 0x6b, 0x35, 0x36, 0xef, 0x3b, 0x18, 0xe0, 0x8c, 0x78,
	0x79, 0xae, 0x16, 0x22, 0xbd, 0xbe, 0x93, 0x73, 0x1f, 0x68, 0x31, 0x69, 0xb9, 0x1c, 0xbd, 0x55,
	0xeb, 0x20, 0x51, 0x7b, 0xb6, 0x12, 0xf1, 0x7e, 0x23, 0xb0, 0x57, 0x0c, 0x3b, 0xc6, 0x79, 0x24,
	0xfd, 0x04, 0xec, 0xa0, 0x60, 0x97, 0x1b, 0x7f, 0xcb, 0xaf, 0xd7, 0x6c, 0x60, 0x6e, 0x7f, 0x39,
	0xc0, 0xfd, 0xba, 0x9c, 0xef, 0xbf, 0x37, 0xe1, 0x22, 0xf1, 0x6a, 0x13, 0x7e, 0x21, 0xdb, 0x9e,
	0x49, 0x7a, 0x1f, 0x2c, 0x25, 0xbb, 0x60, 0x78, 0xc3, 0xdf, 0xaa, 0xf0, 0x35, 0xd3, 0x7c, 0x7b,
	0xe8, 0x5a, 0xf7, 0x73, 0xe8, 0x55, 0xc2, 0x0d, 0xcc, 0xee, 0xd6, 0x99, 0x0d, 0xb6, 0x74, 0x57,
	0x59, 0xfd, 0x48, 0xa0, 0x7f, 0x7a, 0xed, 0x17, 0x60, 0xf5, 0xc2, 0x6b, 0x5f, 0x76, 0xe1, 0xed,
	0xd5, 0x18, 0xc8, 0xc3, 0xbf, 0x5b, 0x60, 0x7f, 0x81, 0x4f, 0xad, 0x93, 0xf0, 0xc5, 0x9a, 0xde,
	0x84, 0x0e, 0x3e, 0x57, 0x56, 0x81, 0xa0, 0x1d, 0x5f, 0xbf, 0xb6, 0xdc, 0xfc, 0x43, 0x7a, 0x3b,
	0xf4, 0xae, 0x3a, 0xa7, 0x28, 0x0e, 0xdf, 0x23, 0xb4, 0xe7, 0x97, 0x4f, 0x13, 0xb7, 0xe3, 0xeb,
	0x3f, 0x77, 0x6f, 0x87, 0xbe, 0x01, 0x06, 0xa6, 0x2d, 0x5f, 0x67, 0xf4, 0x2f, 0x26, 0xde, 0x05,
	0x28, 0x6f, 0x6a, 0xba, 0xeb, 0x57, 0xff, 0x0c, 0xdc, 0x1a, 0xcc, 0xab, 0x4f, 0xab, 0xd5, 0xa7,
	0xf5, 0xea, 0xd3, 0x7a, 0xf5, 0x3d, 0x80, 0xcd, 0xb1, 0x93, 0xb4, 0x5f, 0x39, 0xf6, 0xe7, 0x6e,
	0x15, 0x61, 0xed, 0x07, 0xb0, 0x5b, 0x6b, 0x3d, 0xdd, 0xdf, 0xda, 0x0a, 0xe7, 0xee, 0x76, 0x04,
	0x87, 0x3d, 0x84, 0xfd, 0xed, 0xa3, 0x4f, 0x1b, 0x6e, 0x83, 0x73, 0xb7, 0xe9, 0x8a, 0xf0, 0x76,
	0x3e, 0x6d, 0x7f, 0xdf, 0x5a, 0x9e, 0x9d, 0x59, 0xea, 0x3d, 0xfb, 0xfe, 0x3f, 0x01, 0x00, 0x00,
	0xff, 0xff, 0xde, 0xa5, 0xf4, 0xbc, 0xe2, 0x0a, 0x00, 0x00,
}
